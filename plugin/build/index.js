const { withAppDelegate, withPlugins, withDangerousMod } = require('@expo/config-plugins');
const { resolve } = require('path');
const { readFileSync, writeFileSync, existsSync } = require('fs');

function createFunctionIfNotExists(lines, fc, content, ret) {
  let index = lines.findIndex(line => line.indexOf(fc) != -1);

  if (index != -1) {
    lines.splice(index + 2, 0, ...[
      '//Start code generated by react-native-notification-ios-plugin',
     ...content,
      '//End code generated by react-native-notification-ios-plugin'
    ]);
  } else {
    index = lines.findIndex(line => line.indexOf('@end') != -1);

    lines.splice(index, 0, ...[
      '//Start function generated by react-native-notification-ios-plugin', 
      fc, 
      '{', 
      ...content, 
      ret, 
      '}', 
      '//End function generated by react-native-notification-ios-plugin',
      ''
    ].filter(line => line != null));
  }
}

function withPlPod(config) {
  return withDangerousMod(config, [
    'ios',
    (cfg) => {
      const { platformProjectRoot, projectName } = cfg.modRequest;
      const delegateHPath = resolve(platformProjectRoot, projectName, 'AppDelegate.h');

      if (existsSync(delegateHPath)) {
        const contents = readFileSync(delegateHPath, 'utf-8');
        let lines = contents.split('\n');

        lines.unshift('#import <UserNotifications/UNUserNotificationCenter.h>');

        lines = lines.map(line => {
          if ((/@interface AppDelegate\s*:\s*EXAppDelegateWrapper/).test(line)) {

            const reg = /(EXAppDelegateWrapper)(\s*)\<(.+)\>/;

            if (reg.test(line)) {
              return line.replace(reg, '$1$2<$3, UNUserNotificationCenterDelegate>');
            } else {
              return line.replace('EXAppDelegateWrapper', 'EXAppDelegateWrapper <UNUserNotificationCenterDelegate>');
            }
          }

          return line;
        });

        writeFileSync(
          delegateHPath,
          lines.join('\n')
        );
      }

      return cfg;
    }
  ]);
}

function withPlAppDelegate(config) {
  return withAppDelegate(config, (cfg) => {
    const { modResults } = cfg;
    const { contents } = modResults;
    let lines = contents.split('\n');

    lines.unshift(
      '#import <UserNotifications/UserNotifications.h>',
      '#import <RNCPushNotificationIOS.h>'
    );

    createFunctionIfNotExists(
      lines,
      '- (void)application:(UIApplication *)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken',
      ['[RNCPushNotificationIOS didRegisterForRemoteNotificationsWithDeviceToken:deviceToken];']
    );
    createFunctionIfNotExists(
      lines,
      '- (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo fetchCompletionHandler:(void (^)(UIBackgroundFetchResult))completionHandler',
      ['[RNCPushNotificationIOS didReceiveRemoteNotification:userInfo fetchCompletionHandler:completionHandler];']
    );
    createFunctionIfNotExists(
      lines,
      '- (void)application:(UIApplication *)application didFailToRegisterForRemoteNotificationsWithError:(NSError *)error',
      ['[RNCPushNotificationIOS didFailToRegisterForRemoteNotificationsWithError:error];']
    );
    createFunctionIfNotExists(
      lines,
      '- (void)userNotificationCenter:(UNUserNotificationCenter *)center didReceiveNotificationResponse:(UNNotificationResponse *)response withCompletionHandler:(void (^)(void))completionHandler',
      ['[RNCPushNotificationIOS didReceiveNotificationResponse:response];']
    );
    createFunctionIfNotExists(
      lines,
      '- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions',
      [
        'UNUserNotificationCenter *center = [UNUserNotificationCenter currentNotificationCenter];',
        'center.delegate = self;'
      ], 'return YES;'
    );
    createFunctionIfNotExists(
      lines,
      '-(void)userNotificationCenter:(UNUserNotificationCenter *)center willPresentNotification:(UNNotification *)notification withCompletionHandler:(void (^)(UNNotificationPresentationOptions options))completionHandler',
      [
        'completionHandler(UNNotificationPresentationOptionSound | UNNotificationPresentationOptionAlert | UNNotificationPresentationOptionBadge);'
      ]
    );

    modResults.contents = lines.join('\n');

    return cfg;
  });
}

function withConfigsPlPlugin(config) {
  return withPlugins(config, [
    withPlPod,
    withPlAppDelegate,
  ]);
}

module.exports = withConfigsPlPlugin;